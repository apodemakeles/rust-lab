在Rust中，一切皆有生命周期标识符，只不过很多都省略了。哪怕是在泛型声明中的T，例如mod1::f1，拓展之后其实就是m1::f2。

对于调用f1的三种情况：

1. 对于一个拥有ownership的类型，其lifetime标识符可以认为是省略的'static，并不是说在整个运行声明周期都有效，而是代表只要有所有权，就有效
2. "hello, world"字面量是一个&'static，整个运行声明周期都有效
3. 捕捉的为s的生命周期

impl Trait这种情况也具有生命周期，m2::f1可以扩展成m2::f2，编译器会自动捕捉入参的生命周期，

而dyn Trait的情况则不同，Box<dyn T>则默认T为'static，所有m3::f1必须用T: Foo + 'static来限定。

更复杂的情况是在异步中。m4中的async函数f1，其返回的值实际上会被编译器生成一个Future
Trait实现的结构体，保存了上下文等信息，编译器会捕捉入参s的生命周期作为这个结构体的lifetime标识符(或其中之一)
。所以test1会由于生命周期问题而编译不通过。

而f2则不同，自己标明的返回值impl Future<Output=()>,并没有捕获任何生命周期，实际是一个impl Future<Output=()> + '
static。所以test2可以正常运行。如果改写成f3的形式，结果就和f1一样了。

受此启发，当在async函数传入多个引用参数时，如果不希望生成的Future实现受其中某几个生命周期的影响，可以改为手写f2的形式。